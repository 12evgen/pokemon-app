#!/usr/bin/env node

// Script for producing releases

// Imports
const path = require('path')
const ora = require('ora')
const fse = require('fs-extra')
const {exec} = require('child_process')

const buildFolder = 'build'
const staticFiles = [
  'README.md',
  'LICENSE',
  'yarn.lock',
  ['bin/server.prod.js', 'index.js']
]

// Arguments
const args = getProcessArgs()
const isBuild = !!args.build

// Constants
const basePath = path.resolve(__dirname, '..')
const buildPath = path.resolve(basePath, buildFolder)

// Run steps
start()
  .then(isBuild ? removeBuildFolder : skip)
  .then(isBuild ? installNodeModules : skip)
  .then(isBuild ? buildLibrary : skip)
  .then(isBuild ? copyStaticFiles : skip)
  .then(isBuild ? createPackageJson : skip)
  .catch(catchError)

//
// STEPS
//

function removeBuildFolder () {
  return log(`Removing build folder (./${buildFolder})`, (resolve, reject) => {
    removeFolder(buildPath, err => {
      if (err) {
        reject(err)
        return
      }
      resolve()
    })
  })
}

function installNodeModules () {
  return log(`Installing node_modules`, (resolve, reject) => {
    runNpmInstall(err => {
      if (err) {
        reject(err)
        return
      }
      resolve()
    })
  })
}

function buildLibrary () {
  return log(`Building application (./${buildFolder})`, (resolve, reject) => {
    runCmd(`$(npm bin)/webpack --config webpack/client.prod.js`, err => {
      if (err) {
        reject(err)
        return
      }
      runCmd(`$(npm bin)/webpack --config webpack/server.prod.js`, err => {
        if (err) {
          reject(err)
          return
        }
        resolve()
      })
    })
  })
}

function copyStaticFiles () {
  return Promise.all(staticFiles.map(file => {
    const isCompound = Array.isArray(file)
    const srcFile = isCompound ? file[0] : file
    const buildFile = isCompound ? file[1] : file

    return log(`Copying file ${srcFile}`, (resolve, reject) => {
      const filePathSrc = path.resolve(basePath, srcFile)
      const filePathBuild = path.resolve(buildPath, buildFile)

      copyFile(filePathSrc, filePathBuild, err => {
        if (err) {
          reject(err)
          return
        }
        resolve()
      })
    })
  }))
}

function createPackageJson () {
  return log(`Creating package.json for publication`, (resolve, reject) => {
    getPackageObj((err, packageObj) => {
      if (err) {
        reject(err)
        return
      }

      const {
        name,
        version,
        description,
        keywords,
        author,
        license,
        bugs,
        homepage,
        repository,
        publishConfig,
        peerDependencies,
        dependencies
      } = packageObj

      const buildPackageJsonData = JSON.stringify({
        name,
        version,
        description,
        keywords,
        author,
        license,
        bugs,
        homepage,
        repository,
        publishConfig,
        main: `index.js`,
        bin: {
          'pokemon-app': 'index.js'
        },
        peerDependencies,
        dependencies
      }, null, 2)

      const buildPackageJsonPath = path.resolve(buildPath, 'package.json')
      createFile(buildPackageJsonPath, buildPackageJsonData, err => {
        if (err) {
          reject(err)
          return
        }
        resolve()
      })
    })
  })
}

//
// UTILS
//

function getProcessArgs () {
  const args = {}
  const argsAcceptable = [
    '--build'
  ]
  const argsAcceptableMsg = `Acceptable arguments: ${argsAcceptable.join(', ')}.`
  const argsProcess = process.argv.slice(2)

  if (!argsProcess.length) {
    throw Error(`No arguments are passed. ${argsAcceptableMsg}`)
  }
  argsProcess.forEach((arg = '') => {
    const argMatch = arg.match(/--([^=]+)(?:=(.*))?/) || []
    const argBase = argMatch[1] || ''
    const argValue = argMatch[2] || true

    if (~argsAcceptable.indexOf(`--${argBase}`)) {
      args[argBase] = argValue
    } else {
      throw Error(`Argument "${arg}" is incorrect. ${argsAcceptableMsg}`)
    }
  })

  return args
}

function runNpmInstall (callback) {
  runCmd(`yarn install`, callback)
}

function removeFolder (folderPath, callback) {
  fse.remove(folderPath, callback)
}

function copyFile (filePathSrc, filePathDest, callback) {
  fse.copy(filePathSrc, filePathDest, callback)
}

function createFile (filePath, fileData, callback) {
  fse.writeFile(filePath, fileData, callback)
}

function getPackageObj (callback) {
  const packageJsonPath = path.resolve(basePath, 'package.json')
  fse.readJson(packageJsonPath, (err, packageObj) => {
    if (err) {
      callback(err)
      return
    }
    callback(null, packageObj)
  })
}

function runCmd (cmd, callback, options = {}) {
  options = {
    // Warning! If the "env" setting is defined then global environment variables aren't used.
    cwd: basePath,
    ...options
  }
  exec(cmd, options, (err, stdout = '') => {
    if (err) {
      callback(err)
      return
    }
    callback(null, stdout.trim())
  })
}

function start (...args) {
  return Promise.resolve(...args)
}

function skip () {
  return Promise.resolve()
}

function log (message, callback) {
  const promise = new Promise(callback)
  ora.promise(promise, message)
  return promise
}

function catchError (error = {}) {
  console.error(`ERROR\n${error.message || error}\n`)
  process.exit(1)
}
